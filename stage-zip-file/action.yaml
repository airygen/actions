name: Stage & Zip WordPress Plugin
description: Stage WordPress plugin files into .release and create a versioned zip.

inputs:
  plugin_file:
    required: true
    description: Main plugin file (e.g., airyseo.php)
  plugin_version:
    required: true
    description: Normalized version tag (e.g., 1.2.3)
  plugin_slug:
    required: true
    description: Plugin slug for zip naming (e.g., airyseo)

  # Multiline "arrays"
  stage_dirs:
    required: false
    default: ""
    description: |
      Multiline list of directories to include if exist.
      Example:
        languages
        inc
        src
        resources
        vendor
  extra_files:
    required: false
    default: ""
    description: |
      Multiline list of files to include if exist.
      Example:
        uninstall.php
        LICENSE
        composer.json

  readme_case_insensitive:
    required: false
    default: "true"
    description: Whether to detect README.txt case-insensitively (true/false)
  release_dir:
    required: false
    default: ".release"
    description: Staging directory
  zip_outdir:
    required: false
    default: "."
    description: Output directory for the zip

outputs:
  zip_path:
    description: Full path to the generated zip
    value: ${{ steps.mkzip.outputs.zip_path }}

runs:
  using: "composite"
  steps:
    - name: Stage payload
      shell: bash
      run: |
        set -euo pipefail

        RELEASE_DIR="${{ inputs.release_dir }}"
        PLUGIN_FILE="${{ inputs.plugin_file }}"

        # Parse multiline "arrays" into bash arrays
        readarray -t STAGE_DIRS <<< "${{ inputs.stage_dirs }}"
        readarray -t EXTRA_FILES <<< "${{ inputs.extra_files }}"

        rm -rf "$RELEASE_DIR"
        mkdir -p "$RELEASE_DIR"

        # 1) Directories (optional, preserve structure)
        for d in "${STAGE_DIRS[@]}"; do
          [[ -z "${d// }" ]] && continue
          if [ -d "$d" ]; then
            mkdir -p "$RELEASE_DIR/$d"
            rsync -a "$d"/ "$RELEASE_DIR/$d"/
          fi
        done

        # 2) Main plugin file (required)
        if [ ! -f "$PLUGIN_FILE" ]; then
          echo "Plugin main file not found: $PLUGIN_FILE"
          exit 1
        fi
        cp -v "$PLUGIN_FILE" "$RELEASE_DIR/"

        # 3) README.txt (case-insensitive optional)
        if [ "${{ inputs.readme_case_insensitive }}" = "true" ]; then
          README_FILE=$(ls -1 | grep -i -x 'readme.txt' | head -n1 || true)
          if [ -n "$README_FILE" ]; then
            # Normalize to README.txt in the payload
            cp -v "$README_FILE" "$RELEASE_DIR/README.txt"
          fi
        else
          [ -f README.txt ] && cp -v README.txt "$RELEASE_DIR/" || true
        fi

        # 4) Extra files (optional)
        for f in "${EXTRA_FILES[@]}"; do
          [[ -z "${f// }" ]] && continue
          [ -f "$f" ] && cp -v "$f" "$RELEASE_DIR/" || true
        done

        echo "Staged payload tree:"
        (cd "$RELEASE_DIR" && find . -maxdepth 2 -print)

    - name: Create zip
      id: mkzip
      shell: bash
      run: |
        set -euo pipefail

        RELEASE_DIR="${{ inputs.release_dir }}"
        OUTDIR="${{ inputs.zip_outdir }}"
        ZIP_NAME="${{ inputs.plugin_slug }}-${{ inputs.plugin_version }}.zip"

        mkdir -p "$OUTDIR"
        (cd "$RELEASE_DIR" && zip -r "../$ZIP_NAME" .)

        # Resolve absolute path if possible; fall back to OUTDIR/ZIP_NAME
        if command -v realpath >/dev/null 2>&1; then
          ZIP_PATH="$(cd "$OUTDIR" && realpath "$ZIP_NAME")"
        else
          ZIP_PATH="$OUTDIR/$ZIP_NAME"
        fi

        echo "zip_path=$ZIP_PATH" >> "$GITHUB_OUTPUT"
        echo "Created: $ZIP_PATH"
